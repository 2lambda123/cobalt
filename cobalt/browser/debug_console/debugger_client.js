function DebuggerClient() {
  this.scripts = [];
}

// Attaches to the debugger and listens for debug events.
DebuggerClient.prototype.attach = function() {
  this.scripts = [];
  debugHub.debugger.onEvent.addListener(this.onEvent.bind(this));
  debugHub.debugger.attach(this.onAttach.bind(this));
}

// Local method to list the parsed scripts the client has been notifed of
// via the |Debugger.scriptParsed| event. Maps the possibly very long script id
// from the debug server to a more human-readable 0-based index.
DebuggerClient.prototype.getScripts = function(scriptId) {
  for (var i in this.scripts) {
    var index = this.pad(i, 3);
    var scriptUrl = this.scripts[i].url;
    printToMessageLog(messageLog.INTERACTIVE, index + ': ' + scriptUrl);
  }
}

//--- Commands.

// Each debugger command has an associated callback to get the result.

DebuggerClient.prototype.getScriptSource = function(scriptId) {
  // If the id looks like an index into the local script array, look it up there.
  if (scriptId >= 0 && scriptId < this.scripts.length) {
    scriptId = this.scripts[scriptId].scriptId;
  }

  var method = 'Debugger.getScriptSource';
  var commandParams = { 'scriptId': scriptId.toString() };
  var callback = this.getScriptSourceCallback.bind(this);
  this.sendCommand(method, commandParams, callback);
}

DebuggerClient.prototype.getScriptSourceCallback = function(result) {
  var scriptSource = result.scriptSource;
  var lines = scriptSource.split('\n');
  for (var i = 0; i < lines.length; i++) {
    var index = this.pad(i + 1, 4);
    printToMessageLog(messageLog.INTERACTIVE, index + ': ' + lines[i]);
  }
}

// All debugger commands are routed through this method. Converts the command
// parameters into a JSON string to pass to the debug server.
DebuggerClient.prototype.sendCommand = function(method, commandParams,
                                                callback) {
  var jsonParams = JSON.stringify(commandParams);
  var commandCallback = this.commandCallback.bind(this, callback);
  debugHub.debugger.sendCommand(method, jsonParams, commandCallback);
}

// All command callbacks are routed through this method. Parses the JSON
// response from the debug server, checks for errors and passes on to the
// command-specific callback to handle the result.
DebuggerClient.prototype.commandCallback = function(callback, responseString) {
  var response = JSON.parse(responseString);

  if (response && response.result) {
    if (callback) {
      callback(response.result);
    } else {
      printToMessageLog(messageLog.INTERACTIVE,
                        "Unhandled response: " + responseString);
    }
  } else if (response && response.error && response.error.message) {
    printToMessageLog(messageLog.INTERACTIVE,
                      "Error: " + response.error.message);
  } else {
    printToMessageLog(messageLog.INTERACTIVE,
                      "Invalid response received: " + responseString);
  }
}

//-- Events.

DebuggerClient.prototype.onAttach = function() {
  printToMessageLog(messageLog.INTERACTIVE, 'Debugger attached.');
}

// All events generated by the debug server are routed through this method.
// Parses the JSON string and passes on to the appropriate handler according to
// the method name.
DebuggerClient.prototype.onEvent = function(method, paramString) {
  var params = JSON.parse(paramString);
  if (method == 'Debugger.scriptParsed') {
    this.onScriptParsed(params);
  } else {
    printToMessageLog(messageLog.INTERACTIVE, 'Unknown event: ');
    printToMessageLog(messageLog.INTERACTIVE, '  ' + method);
    if (paramString) {
      printToMessageLog(messageLog.INTERACTIVE, '  ' + paramString);
    }
  }
}

DebuggerClient.prototype.onScriptParsed = function(params) {
  this.scripts.push(params);
}

//--- Utils.

DebuggerClient.prototype.pad = function(number, minLength) {
  var result = number.toString();
  while (result.length < minLength) {
    result = ' ' + result;
  }
  return result;
}